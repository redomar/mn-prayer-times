/**
 * Prayer time collection with full observability
 *
 * This module refactors the prayer time fetching logic to use Effect-based
 * observability, providing full context propagation, structured logging,
 * and distributed tracing.
 */

import { Effect } from "effect";
import { api, APIError, ErrCode } from "encore.dev/api";
import { secret } from "encore.dev/config";
import { db } from "./database";
import { prayerTimes } from "./schema";
import { PrayerTimes } from "./times";
import {
  ObservabilityLive,
  LoggerService,
  TracerService,
  logger,
} from "./observability";
import {
  withObservability,
  withRetry,
  withHtmlParsing,
  withDatabase,
} from "./observability/effects";

const LONDON_API_KEY = secret("LONDON_PRAYER_TIMES_API");

// --- Helper Functions (kept as-is for compatibility) ---

const cleanHtmlString = (html: string): string => {
  const regex = /(&nbsp;|<([^>]+)>)/gi;
  return html.replace(regex, "").trim();
};

async function fetchHtmlViaPost(
  url: string,
  bodyParams: Record<string, string>
): Promise<string> {
  const options = {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: new URLSearchParams(bodyParams),
  };
  const response = await fetch(url, options);
  if (!response.ok) {
    throw new APIError(
      ErrCode.Internal,
      `Failed to fetch data from ${url}: ${response.statusText}`
    );
  }
  return response.text();
}

function extractTableRows(htmlData: string): string[] {
  const match = htmlData.match(/<tr[\s\S]*?<\/tr>/g);
  return match || [];
}

function extractAndCleanTableCells(rowHtml: string): string[] {
  const cellMatch = rowHtml.match(/<td[\s\S]*?<\/td>/g);
  if (!cellMatch) {
    throw new APIError(
      ErrCode.Internal,
      "Failed to parse table cells from a row"
    );
  }
  return cellMatch.map(cleanHtmlString);
}

function getCurrentDateParts() {
  const now = new Date();
  const shortMonth = now.toLocaleString("en-GB", { month: "short" });
  return {
    longMonth: now.toLocaleString("en-GB", { month: "long" }),
    shortMonth: shortMonth,
    shortMonth3Char: shortMonth.slice(0, 3),
    numericYear: now.getFullYear(),
    year: now.getFullYear().toString(),
  };
}

async function saveAndReturnPrayerTimes(
  timesToSave: (typeof prayerTimes.$inferInsert)[]
) {
  if (!timesToSave || timesToSave.length === 0) {
    return [];
  }
  return db.insert(prayerTimes).values(timesToSave).returning();
}

// --- London with Observability ---

async function fetchLondonPrayerTimes(year: number, month: string) {
  const url = `https://www.londonprayertimes.com/api/times/?format=json&key=${LONDON_API_KEY()}&year=${year}&month=${month}&24hours=true`;

  const response = await fetch(url);

  if (!response.ok) {
    throw new APIError(
      ErrCode.Internal,
      `Failed to fetch London prayer times: ${response.statusText}`
    );
  }

  const unwrappedData = await response.json();

  if (
    !unwrappedData?.times ||
    typeof unwrappedData.times !== "object" ||
    Object.keys(unwrappedData.times).length === 0
  ) {
    logger.warn({
      year,
      month,
    }, "No London prayer times data found in API response");
    throw new APIError(
      ErrCode.Internal,
      "No London prayer times data found or data is empty"
    );
  }

  return {
    data: unwrappedData,
  };
}

export const collectFromLondon = api(
  { method: "GET", path: "/collect/london" },
  async () => {
    const program = Effect.gen(function* () {
      const { longMonth, numericYear } = getCurrentDateParts();

      const context = {
        location: "London",
        locationId: 1,
        operation: "fetch_prayer_times",
        month: longMonth,
        year: numericYear.toString(),
      };

      // Fetch with observability
      const result = yield* withObservability(context, () =>
        fetchLondonPrayerTimes(numericYear, longMonth)
      );

      const times = result.data.times;

      // Transform data
      const body: (typeof prayerTimes.$inferInsert)[] = Object.keys(times).map(
        (date) => {
          const time = times[date];
          return {
            date: date,
            locationId: 1,
            fajr: time.fajr,
            fajrJamat: time.fajr_jamat,
            dhuhr: time.dhuhr,
            dhuhrJamat: time.dhuhr_jamat,
            asr: time.asr,
            asr2: time.asr_2,
            asrJamat: time.asr_jamat,
            maghrib: time.magrib,
            maghribJamat: time.magrib_jamat,
            isha: time.isha,
            ishaJamat: time.isha_jamat,
            sunrise: time.sunrise,
          };
        }
      );

      // Save to database with observability
      const savedPrayerTimes = yield* withDatabase(
        { ...context, operation: "save_prayer_times", count: body.length },
        () => saveAndReturnPrayerTimes(body)
      );

      return savedPrayerTimes;
    });

    try {
      const result = await Effect.runPromise(
        Effect.provide(program, ObservabilityLive)
      );
      return { status: ErrCode.OK, body: result };
    } catch (error) {
      logger.error("London collection failed", {
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
      });

      if (error instanceof APIError) {
        return { status: error.code, error: error.message };
      }
      return {
        status: ErrCode.Internal,
        error: "An unexpected error occurred.",
      };
    }
  }
);

// --- Birmingham with Observability ---

async function fetchBirminghamPrayerTimes(
  month: string,
  year: string
): Promise<PrayerTimes[]> {
  const htmlData = await fetchHtmlViaPost(
    "https://centralmosque.org.uk/wp-admin/admin-ajax.php",
    { action: "fulltabledata", year, month }
  );

  const tableRowsHtml = extractTableRows(htmlData);

  if (tableRowsHtml.length <= 1) {
    throw new APIError(
      ErrCode.Internal,
      "Failed to parse table rows or insufficient data for Birmingham"
    );
  }

  const parseTime = (timeStr: string): string => {
    if (!timeStr) return "";
    const cleanedTime = timeStr.replace(/\s/g, "").toUpperCase();
    const matches = cleanedTime.match(/(\d+):?(\d+)?(AM|PM)/);
    if (!matches) return "";

    const [, hours, minutes, period] = matches;
    let hr = parseInt(hours);
    const min = minutes ? parseInt(minutes) : 0;

    if (period === "PM" && hr < 12) hr += 12;
    if (period === "AM" && hr === 12) hr = 0;

    return `${hr.toString().padStart(2, "0")}:${min
      .toString()
      .padStart(2, "0")}`;
  };

  const parseDate = (
    dayOfMonthStr: string,
    currentMonth: string,
    currentYear: string
  ): string => {
    const cleanedDay = dayOfMonthStr.replace(/\b(\d+)(st|nd|rd|th)\b/, "$1");
    const dateStr = `${cleanedDay} ${currentMonth} ${currentYear}`;
    return (
      new Date(`${dateStr} 12:00:00 GMT`).toISOString().split("T")[0] ?? ""
    );
  };

  return tableRowsHtml
    .slice(1)
    .map((rowHtml): Partial<PrayerTimes> => {
      try {
        const tdArray = extractAndCleanTableCells(rowHtml);

        if (tdArray.length < 14) {
          logger.warn("Skipping malformed Birmingham row", {
            rowLength: tdArray.length,
            rowPreview: tdArray.slice(0, 3),
          });
          return {};
        }

        return {
          locationId: 2,
          date: parseDate(tdArray[0], month, year),
          fajr: parseTime(tdArray[2]),
          fajrJamat: parseTime(tdArray[3]),
          sunrise: parseTime(tdArray[4]),
          dhuhr: parseTime(tdArray[6]),
          dhuhrJamat: parseTime(tdArray[7]),
          asr: parseTime(tdArray[8]),
          asr2: parseTime(tdArray[8]),
          asrJamat: parseTime(tdArray[9]),
          maghrib: parseTime(tdArray[10]),
          maghribJamat: parseTime(tdArray[11]),
          isha: parseTime(tdArray[12]),
          ishaJamat: parseTime(tdArray[13]),
        };
      } catch (error) {
        logger.warn("Error parsing Birmingham row", {
          error: error instanceof Error ? error.message : String(error),
        });
        return {};
      }
    })
    .filter((pt) => pt.date) as PrayerTimes[];
}

export const collectFromBirmingham = api(
  { method: "GET", path: "/collect/birmingham" },
  async () => {
    const program = Effect.gen(function* () {
      const { longMonth, shortMonth, shortMonth3Char, year } =
        getCurrentDateParts();

      const context = {
        location: "Birmingham",
        locationId: 2,
        operation: "fetch_prayer_times",
        year,
      };

      // Retry with different month formats
      const data = yield* withRetry(
        context,
        [
          () => fetchBirminghamPrayerTimes(longMonth, year),
          () => fetchBirminghamPrayerTimes(shortMonth, year),
          () => fetchBirminghamPrayerTimes(shortMonth3Char, year),
        ],
        [
          `long month (${longMonth})`,
          `short month (${shortMonth})`,
          `3-char month (${shortMonth3Char})`,
        ]
      );

      if (!data || data.length === 0) {
        throw new Error("Birmingham prayer times data is empty after all attempts");
      }

      // Save to database
      const validData: (typeof prayerTimes.$inferInsert)[] = data.map((pt) => ({
        ...pt,
        locationId: 2,
      }));

      const savedPrayerTimes = yield* withDatabase(
        { ...context, operation: "save_prayer_times", count: validData.length },
        () => saveAndReturnPrayerTimes(validData)
      );

      return savedPrayerTimes;
    });

    try {
      const result = await Effect.runPromise(
        Effect.provide(program, ObservabilityLive)
      );
      return { status: ErrCode.OK, body: result };
    } catch (error) {
      logger.error("Birmingham collection failed", {
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
      });

      if (error instanceof APIError) {
        return { status: error.code, error: error.message };
      }
      return {
        status: ErrCode.Internal,
        error: "An unexpected error occurred.",
      };
    }
  }
);

// --- Manchester with Observability ---

async function fetchManchesterPrayerTimesFor(
  month: string,
  year: string
): Promise<PrayerTimes[]> {
  const htmlData = await fetchHtmlViaPost(
    "https://manchestercentralmosque.org/wp-admin/admin-ajax.php",
    { current_file: `${month} ${year}`, action: "mcm_get_month_file" }
  );

  const tableRowsHtml = extractTableRows(htmlData);

  if (tableRowsHtml.length <= 1) {
    throw new APIError(
      ErrCode.Internal,
      "Failed to parse table rows or insufficient data for Manchester"
    );
  }

  const parseTimeForManchester = (timeStr: string, period: string): string => {
    if (!timeStr || !timeStr.includes(".")) return "";
    const parts = timeStr.split(".");
    if (parts.length !== 2) return "";

    const hours = parseInt(parts[0]);
    const minutes = parseInt(parts[1]);
    if (isNaN(hours) || isNaN(minutes)) return "";

    let adjustedHours = hours;
    if (period === "AM" && hours === 12) adjustedHours = 0;
    else if (period === "PM" && hours !== 12) adjustedHours += 12;

    return `${adjustedHours.toString().padStart(2, "0")}:${minutes
      .toString()
      .padStart(2, "0")}`;
  };

  const determinePeriodForManchester = (prayerIndex: number): string => {
    if (prayerIndex <= 2) return "AM";
    return "PM";
  };

  const parseDateForManchester = (
    dayOfMonth: string,
    currentMonth: string,
    currentYear: string
  ): string => {
    const dateStr = `${dayOfMonth} ${currentMonth} ${currentYear}`;
    return (
      new Date(`${dateStr} 12:00:00 GMT`).toISOString().split("T")[0] ?? ""
    );
  };

  return tableRowsHtml
    .map(extractAndCleanTableCells)
    .filter(
      (tdArray) =>
        tdArray.length > 0 &&
        !isNaN(parseInt(tdArray[0])) &&
        parseInt(tdArray[0]) > 0
    )
    .map((tdArray): Partial<PrayerTimes> => {
      try {
        if (tdArray.length < 15) {
          logger.warn("Skipping malformed Manchester row", {
            rowLength: tdArray.length,
            rowPreview: tdArray.slice(0, 3),
          });
          return {};
        }

        const dayStr = tdArray[0];

        return {
          locationId: 3,
          date: parseDateForManchester(dayStr, month, year),
          fajr: parseTimeForManchester(
            tdArray[3],
            determinePeriodForManchester(0)
          ),
          fajrJamat: parseTimeForManchester(
            tdArray[10],
            determinePeriodForManchester(1)
          ),
          sunrise: parseTimeForManchester(
            tdArray[4],
            determinePeriodForManchester(2)
          ),
          dhuhr: parseTimeForManchester(
            tdArray[6],
            determinePeriodForManchester(3)
          ),
          dhuhrJamat: parseTimeForManchester(
            tdArray[11],
            determinePeriodForManchester(3)
          ),
          asr: parseTimeForManchester(
            tdArray[7],
            determinePeriodForManchester(4)
          ),
          asr2: parseTimeForManchester(
            tdArray[7],
            determinePeriodForManchester(4)
          ),
          asrJamat: parseTimeForManchester(
            tdArray[12],
            determinePeriodForManchester(4)
          ),
          maghrib: parseTimeForManchester(
            tdArray[8],
            determinePeriodForManchester(5)
          ),
          maghribJamat: parseTimeForManchester(
            tdArray[13],
            determinePeriodForManchester(5)
          ),
          isha: parseTimeForManchester(
            tdArray[9],
            determinePeriodForManchester(6)
          ),
          ishaJamat: parseTimeForManchester(
            tdArray[14],
            determinePeriodForManchester(6)
          ),
        };
      } catch (error) {
        logger.warn("Error parsing Manchester row", {
          error: error instanceof Error ? error.message : String(error),
        });
        return {};
      }
    })
    .filter((pt) => pt.date) as PrayerTimes[];
}

export const collectFromManchester = api(
  { method: "GET", path: "/collect/manchester" },
  async () => {
    const program = Effect.gen(function* () {
      const { longMonth, shortMonth, shortMonth3Char, year } =
        getCurrentDateParts();

      const context = {
        location: "Manchester",
        locationId: 3,
        operation: "fetch_prayer_times",
        year,
      };

      // Retry with different month formats
      const data = yield* withRetry(
        context,
        [
          () => fetchManchesterPrayerTimesFor(longMonth, year),
          () => fetchManchesterPrayerTimesFor(shortMonth, year),
          () => fetchManchesterPrayerTimesFor(shortMonth3Char, year),
        ],
        [
          `long month (${longMonth})`,
          `short month (${shortMonth})`,
          `3-char month (${shortMonth3Char})`,
        ]
      );

      if (!data || data.length === 0) {
        throw new Error("Manchester prayer times data is empty after all attempts");
      }

      // Save to database
      const validData: (typeof prayerTimes.$inferInsert)[] = data.map((pt) => ({
        ...pt,
        locationId: 3,
      }));

      const savedPrayerTimes = yield* withDatabase(
        { ...context, operation: "save_prayer_times", count: validData.length },
        () => saveAndReturnPrayerTimes(validData)
      );

      return savedPrayerTimes;
    });

    try {
      const result = await Effect.runPromise(
        Effect.provide(program, ObservabilityLive)
      );
      return { status: ErrCode.OK, body: result };
    } catch (error) {
      logger.error("Manchester collection failed", {
        error: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : undefined,
      });

      if (error instanceof APIError) {
        return { status: error.code, error: error.message };
      }
      return {
        status: ErrCode.Internal,
        error: "An unexpected error occurred.",
      };
    }
  }
);

// --- Retry Manchester Collection (for Cron) ---

export const retryManchesterCollection = api(
  { method: "POST", path: "/retry/manchester" },
  async () => {
    const today = new Date();
    const day = today.getDate();
    const weekday = today.getDay(); // 5 = Friday

    if (weekday === 5 && day <= 7) {
      logger.info("First Friday of month - retrying Manchester collection", {
        date: today.toISOString(),
      });

      try {
        const result = await collectFromManchester();
        return result;
      } catch (error) {
        logger.error("Manchester retry failed", {
          error: error instanceof Error ? error.message : String(error),
        });

        if (error instanceof APIError) {
          return { status: error.code, error: error.message };
        }
        return {
          status: ErrCode.Internal,
          error: "An unexpected error occurred.",
        };
      }
    }

    logger.info("Skipping Manchester retry - not first Friday", {
      date: today.toISOString(),
      day,
      weekday,
    });

    return {
      status: 204,
      body: "Not the first Friday â€” skipping retry",
    };
  }
);

// --- Delete Times by Location and Month ---

export const dropTimesByLocationAndMonthYear = api(
  { method: "DELETE", path: "/times/location/:locationId/:year/:month" },
  async (p: { locationId: number; year: number; month: number }) => {
    const program = Effect.gen(function* () {
      const dateRangeTheYearMonthsStart = new Date(p.year, p.month - 1, 1);
      const dateRangeTheYearMonthsEnd = new Date(p.year, p.month, 0);

      const context = {
        location: `Location ${p.locationId}`,
        locationId: p.locationId,
        operation: "delete_prayer_times",
        year: p.year,
        month: p.month,
        dateRange: {
          start: dateRangeTheYearMonthsStart.toISOString(),
          end: dateRangeTheYearMonthsEnd.toISOString(),
        },
      };

      yield* withDatabase(context, async () => {
        const { and, eq, sql } = await import("drizzle-orm");
        await db
          .delete(prayerTimes)
          .where(
            and(
              eq(prayerTimes.locationId, p.locationId),
              sql`date >= ${dateRangeTheYearMonthsStart.toISOString()} AND date <= ${dateRangeTheYearMonthsEnd.toISOString()}`
            )
          );
        return null;
      });

      return null;
    });

    try {
      await Effect.runPromise(Effect.provide(program, ObservabilityLive));
      return { status: ErrCode.OK, body: null };
    } catch (error) {
      logger.error("Delete prayer times failed", {
        locationId: p.locationId,
        year: p.year,
        month: p.month,
        error: error instanceof Error ? error.message : String(error),
      });

      if (error instanceof APIError) {
        return { status: error.code, error: error.message };
      }
      return {
        status: ErrCode.Internal,
        error: "An unexpected error occurred.",
      };
    }
  }
);
